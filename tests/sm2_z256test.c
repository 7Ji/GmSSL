/*
 *  Copyright 2014-2024 The GmSSL Project. All Rights Reserved.
 *
 *  Licensed under the Apache License, Version 2.0 (the License); you may
 *  not use this file except in compliance with the License.
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 */


#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <stdint.h>
#include <gmssl/sm2_z256.h>
#include <gmssl/hex.h>
#include <gmssl/rand.h>
#include <gmssl/error.h>


static int test_sm2_z256_point_mul_generator(void)
{
	struct {
		char *k;
		char *kG;
	} tests[] = {
		// k = 0
		{"0000000000000000000000000000000000000000000000000000000000000000",
		 "0000000000000000000000000000000000000000000000000000000000000000"
		 "0000000000000000000000000000000000000000000000000000000000000000"},
		// k = 1
		{"0000000000000000000000000000000000000000000000000000000000000001",
		 "32C4AE2C1F1981195F9904466A39C9948FE30BBFF2660BE1715A4589334C74C7"
		 "BC3736A2F4F6779C59BDCEE36B692153D0A9877CC62A474002DF32E52139F0A0"},
		// k = 2
		{"0000000000000000000000000000000000000000000000000000000000000002",
		 "56CEFD60D7C87C000D58EF57FA73BA4D9C0DFA08C08A7331495C2E1DA3F2BD52"
		 "31B7E7E6CC8189F668535CE0F8EAF1BD6DE84C182F6C8E716F780D3A970A23C3"},
		// k = 3
		{"0000000000000000000000000000000000000000000000000000000000000003",
		 "A97F7CD4B3C993B4BE2DAA8CDB41E24CA13F6BD945302244E26918F1D0509EBF"
		 "530B5DD88C688EF5CCC5CEC08A72150F7C400EE5CD045292AAACDD037458F6E6"},
		// k = 4
		{"0000000000000000000000000000000000000000000000000000000000000004",
		 "C239507105C683242A81052FF641ED69009A084AD5CC937DB21646CD34A0CED5"
		 "B1BF7EC4080F3C8735F1294AC0DB19686BEE2E96AB8C71FB7A253666CB66E009"},
		// k = 5
		{"0000000000000000000000000000000000000000000000000000000000000005",
		 "C749061668652E26040E008FDD5EB77A344A417B7FCE19DBA575DA57CC372A9E"
		 "F2DF5DB2D144E9454504C622B51CF38F5006206EB579FF7DA6976EFF5FBE6480"},
		// k = 6
		{"0000000000000000000000000000000000000000000000000000000000000006",
		 "0927AFB57D93483BBB17C93E71F22A3105FF8856A66016892C8B1A1A3C4B0D30"
		 "150C6B1AB4D1FC7EAC1C0EF6EBF2664581ADF1F0855A064DD572103000088F63"},
		// k = 7
		{"0000000000000000000000000000000000000000000000000000000000000007",
		 "DDF092555409C19DFDBE86A75C139906A80198337744EE78CD27E384D9FCAF15"
		 "847D18FFB38E87065CD6B6E9C12D2922037937707D6A49A2223B949657E52BC1"},
		// k = G.x
		{"32C4AE2C1F1981195F9904466A39C9948FE30BBFF2660BE1715A4589334C74C7",
		 "782E1941B8A8C802543BC831E19F3548235C94A9C42AAD1EA8952CEAAECF12BA"
		 "EEE0D9A6939E87F3B47A85863F873B324B9859136E2BF3235E17B3270164202D"},
		// k = G.y
		{"BC3736A2F4F6779C59BDCEE36B692153D0A9877CC62A474002DF32E52139F0A0",
		 "1000165E3FFF85F1DFFFB3AA1DF9F5E62B9A86A9A2927B4FF1AC16D19FEFF330"
		 "3116F22B65320DD3B7F73DCF4A4028063A9BE6EFBD1DB0915C72F1EE067C5ECF"},
		// k = n - 1 = -1
		{"FFFFFFFEFFFFFFFFFFFFFFFFFFFFFFFF7203DF6B21C6052B53BBF40939D54122",
		 "32C4AE2C1F1981195F9904466A39C9948FE30BBFF2660BE1715A4589334C74C7"
		 "43C8C95C0B098863A642311C9496DEAC2F56788239D5B8C0FD20CD1ADEC60F5F"},
		// k = n = 0
		{"FFFFFFFEFFFFFFFFFFFFFFFFFFFFFFFF7203DF6B21C6052B53BBF40939D54123",
		 "0000000000000000000000000000000000000000000000000000000000000000"
		 "0000000000000000000000000000000000000000000000000000000000000000"},
		// k = n + 1 = 1
		{"FFFFFFFEFFFFFFFFFFFFFFFFFFFFFFFF7203DF6B21C6052B53BBF40939D54124",
		 "32C4AE2C1F1981195F9904466A39C9948FE30BBFF2660BE1715A4589334C74C7"
		 "BC3736A2F4F6779C59BDCEE36B692153D0A9877CC62A474002DF32E52139F0A0"},
		// k = 2^256 - 1
		{"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF",
		 "B3217D884BC175E6BA6B360EB0E6D4396EAEA725C3D66E87BFA5BEB6C0D3456B"
		 "A5199445C54B56602AA60025E1907BFD26B30E867DB6C58A034263AE4A2E27C2"},
	};

	uint64_t k[4];
	SM2_Z256_POINT P;
	uint8_t P_bytes[64];
	uint8_t kG_bytes[64];
	size_t i, len;

	for (i = 0; i < sizeof(tests)/sizeof(tests[0]); i++) {

		sm2_z256_from_hex(k, tests[i].k);
		hex_to_bytes(tests[i].kG, strlen(tests[i].kG), kG_bytes, &len);

		sm2_z256_point_mul_generator(&P, k);
		sm2_z256_point_to_bytes(&P, P_bytes);

		if (memcmp(P_bytes, kG_bytes, 64) != 0) {
			error_print();
			return -1;
		}
	}

	printf("%s() ok\n", __FUNCTION__);
	return 1;
}

int main(void)
{
/*
	SM2_POINT P;
	uint8_t k[32] = {0};
	uint8_t i;

	for (i = 0; i < 8; i++) {
		k[31] = i;

		format_bytes(stderr, 0, 0, "k", k, 32);

		sm2_point_mul_generator(&P, k);
		sm2_point_print(stdout, 0, 4, "kG", &P);
	}

	size_t len;

	char *xG = "32C4AE2C1F1981195F9904466A39C9948FE30BBFF2660BE1715A4589334C74C7";
	char *yG = "BC3736A2F4F6779C59BDCEE36B692153D0A9877CC62A474002DF32E52139F0A0";

	hex_to_bytes(xG, strlen(xG), k, &len);

	sm2_point_mul_generator(&P, k);
	format_bytes(stderr, 0, 0, "k", k, 32);
	sm2_point_print(stdout, 0, 4, "kG", &P);

	hex_to_bytes(yG, strlen(yG), k, &len);
	sm2_point_mul_generator(&P, k);
	format_bytes(stderr, 0, 0, "k", k, 32);
	sm2_point_print(stdout, 0, 4, "kG", &P);

	char *n = "fffffffeffffffffffffffffffffffff7203df6b21c6052b53bbf40939d54123";
	char *n_minus_one = "fffffffeffffffffffffffffffffffff7203df6b21c6052b53bbf40939d54122";
	char *n_plus_one = "fffffffeffffffffffffffffffffffff7203df6b21c6052b53bbf40939d54124";
	char *max256 =   "ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff";

	hex_to_bytes(n_minus_one, strlen(n_minus_one), k, &len);
	sm2_point_mul_generator(&P, k);
	format_bytes(stderr, 0, 0, "n-1", k, 32);
	sm2_point_print(stdout, 0, 4, "kG", &P);

	hex_to_bytes(n, strlen(n), k, &len);
	sm2_point_mul_generator(&P, k);
	format_bytes(stderr, 0, 0, "n", k, 32);
	sm2_point_print(stdout, 0, 4, "kG", &P);

	hex_to_bytes(n_plus_one, strlen(n_plus_one), k, &len);
	sm2_point_mul_generator(&P, k);
	format_bytes(stderr, 0, 0, "n+1", k, 32);
	sm2_point_print(stdout, 0, 4, "kG", &P);

	hex_to_bytes(max256, strlen(max256), k, &len);
	sm2_point_mul_generator(&P, k);
	format_bytes(stderr, 0, 0, "n+1", k, 32);
	sm2_point_print(stdout, 0, 4, "kG", &P);

*/
	if (test_sm2_z256_point_mul_generator() != 1) goto err;
	printf("%s all tests passed\n", __FILE__);
	return 0;
err:
	error_print();
	return 1;
}
